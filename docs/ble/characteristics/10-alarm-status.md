# Alarm Status Characteristic

**UUID:** `12345678-1234-5678-1234-56789abcdefa`  
**Properties:** Read, Write, Notify  
**Size:** 7 bytes  
**Description:** Critical alarm and notification management system for irrigation monitoring and error handling

## Overview

The Alarm Status characteristic manages the alarm and notification system for critical issues in the irrigation system. It provides real-time monitoring capabilities with persistent alarm storage and selective clearing functions.

**Immediate Priority:** ‚úÖ Alarm notifications bypass rate limiting for critical alerts  
**Smart Persistence:** ‚úÖ Alarms persist until explicitly cleared  
**Selective Clearing:** ‚úÖ Clear individual alarms or all alarms  
**Diagnostic Integration:** ‚úÖ Timestamps for troubleshooting  
**Fragmentation:** ‚ùå NOT REQUIRED - 7 bytes fit in single BLE packet  
**Priority Notifications:** ‚úÖ Critical alarms bypass 500ms rate limiting for immediate delivery

## Data Structure

```c
struct alarm_data {
    uint8_t alarm_code;       // Alarm code (0=no alarm, 1-13=specific alarms)
    uint16_t alarm_data;      // Additional alarm-specific data (little-endian)
    uint32_t timestamp;       // Unix UTC timestamp when alarm occurred (little-endian)
} __packed;                   // TOTAL SIZE: 7 bytes
```

## Field Descriptions

| Offset | Size | Field | Description |
|--------|------|-------|-------------|
| 0 | 1 | `alarm_code` | Alarm type identifier (0=none, 1-13=specific) |
| 1-2 | 2 | `alarm_data` | Context-specific data (little-endian) |
| 3-6 | 4 | `timestamp` | Unix UTC timestamp (little-endian) |

### alarm_code (byte 0)
- **Range:** 0-13
- **Values:**
  - `0` = No alarm (normal operation)
  - `1` = No flow detected (valve open but no water flow)
  - `2` = Unexpected flow (flow detected with all valves closed)
  - `3-13` = Reserved for future alarm types

### alarm_data (bytes 1-2, little-endian)
- **Purpose:** Additional context specific to alarm type
- **Examples:**
  - **Alarm 1 (No Flow):** Consecutive flow check failures (1-65535)
  - **Alarm 2 (Unexpected Flow):** Pulse count detected (0-65535)
  - **Future Alarms:** Channel ID, error count, sensor values

### timestamp (bytes 3-6, little-endian)
- **Format:** Unix UTC timestamp (seconds since January 1, 1970)
- **Range:** 0-4,294,967,295 (up to year 2106)
- **Precision:** 1-second resolution
- **Source:** Generated by `timezone_get_unix_utc()` function using RTC
- **Persistence:** Maintains accurate time across system reboots
- **Purpose:** Enables precise alarm correlation and troubleshooting

## Alarm Codes Reference

### Active Alarm Codes

| Code | Name | Description | alarm_data Content | System Response |
|------|------|-------------|-------------------|-----------------|
| **0** | No Alarm | Normal operation | 0 | System operational |
| **1** | No Flow | No water flow when valve open | Flow error count (1-3) | Retry task, then fault |
| **2** | Unexpected Flow | Flow with all valves closed | Pulse count detected | Force close valves |

### Reserved Codes (Future)

| Code | Name | Expected Use | Typical alarm_data |
|------|------|--------------|-------------------|
| **3** | Valve Failure | Valve doesn't respond | Channel ID (0-7) |
| **4** | Flow Sensor Error | Sensor malfunction | Sensor reading |
| **5** | Low Pressure | Insufficient water pressure | Pressure reading |
| **6** | RTC Error | Clock failure | Error count |
| **7** | Temperature Alarm | Extreme temperature | Temperature value |
| **8** | Humidity Alarm | Extreme humidity | Humidity percentage |
| **9** | Power Supply | Voltage issues | Voltage reading |
| **10** | Communication Error | Device comm failure | Device ID |
| **11** | Calibration Error | Invalid calibration | Calibration value |
| **12** | Queue Overflow | Too many pending tasks | Queue size |
| **13** | Storage Error | NVS/Flash failure | Error code |

## Operations

### READ - Query Current Alarm
Returns the current alarm status with timestamp and context data.

```javascript
const data = await alarmChar.readValue();
const view = new DataView(data.buffer);

const alarmCode = view.getUint8(0);
const alarmData = view.getUint16(1, true);  // little-endian
const timestamp = view.getUint32(3, true);  // little-endian

// Convert timestamp to readable date
const alarmTime = new Date(timestamp * 1000);

// Parse alarm information
const alarmNames = {
    0: 'No Alarm',
    1: 'No Flow Detected',
    2: 'Unexpected Flow',
    3: 'Valve Failure',
    4: 'Flow Sensor Error',
    5: 'Low Water Pressure',
    6: 'RTC Error',
    7: 'Temperature Alarm',
    8: 'Humidity Alarm',
    9: 'Power Supply Issue',
    10: 'Communication Error',
    11: 'Calibration Error',
    12: 'Task Queue Overflow',
    13: 'Storage Error'
};

if (alarmCode === 0) {
    console.log('System Status: Normal Operation');
} else {
    console.log(`ALARM: ${alarmNames[alarmCode] || 'Unknown'} (Code: ${alarmCode})`);
    console.log(`Context Data: ${alarmData}`);
    console.log(`Occurred: ${alarmTime.toLocaleString()}`);
}
```

### WRITE - Clear Alarms
Clear specific alarms or all alarms using single-byte control commands.

**IMPORTANT:** Alarm clearing uses **1-byte commands**, not the full 7-byte structure!

```javascript
// Clear all alarms
async function clearAllAlarms() {
    const clearCommand = new Uint8Array([0x00]); // Single byte: 0 = clear all
    await alarmChar.writeValue(clearCommand);
    console.log('All alarms cleared');
}

// Clear specific alarm by code (only if currently active)
async function clearSpecificAlarm(alarmCode) {
    if (alarmCode < 1 || alarmCode > 13) {
        console.error('Invalid alarm code. Must be 1-13');
        return false;
    }
    
    // Send single byte with alarm code to clear
    const clearCommand = new Uint8Array([alarmCode]);
    
    try {
        await alarmChar.writeValue(clearCommand);
        console.log(`Sent clear command for alarm ${alarmCode}`);
        
        // Note: Command only succeeds if the specified alarm is currently active
        // The system will ignore the command if a different alarm is active
        return true;
    } catch (error) {
        console.error('Failed to clear alarm:', error);
        return false;
    }
}

// Emergency clear (alias for clearAllAlarms)
async function emergencyClearAlarms() {
    await clearAllAlarms();
    console.log('üö® Emergency alarm clear executed');
}
```

### NOTIFY - Real-time Alarm Updates
Receive immediate notifications when alarms occur or are cleared.

```javascript
await alarmChar.startNotifications();

alarmChar.addEventListener('characteristicvaluechanged', (event) => {
    const data = event.target.value;
    const view = new DataView(data.buffer);
    
    const alarmCode = view.getUint8(0);
    const alarmData = view.getUint16(1, true);
    const timestamp = view.getUint32(3, true);
    const alarmTime = new Date(timestamp * 1000);
    
    if (alarmCode === 0) {
        console.log('‚úÖ ALARM CLEARED - System returned to normal operation');
    } else {
        const alarmNames = {
            1: 'No Flow Detected',
            2: 'Unexpected Flow',
            3: 'Valve Failure',
            4: 'Flow Sensor Error',
            5: 'Low Water Pressure'
            // ... add more as needed
        };
        
        const alarmName = alarmNames[alarmCode] || `Unknown Alarm (${alarmCode})`;
        
        console.log(`üö® CRITICAL ALARM: ${alarmName}`);
        console.log(`   Context: ${alarmData}`);
        console.log(`   Time: ${alarmTime.toLocaleString()}`);
        
        // Handle specific alarm types
        if (alarmCode === 1) {
            console.log(`   Flow check failures: ${alarmData}`);
        } else if (alarmCode === 2) {
            console.log(`   Unexpected pulse count: ${alarmData}`);
        }
        
        // Show user-friendly message
        showAlarmNotification(alarmName, alarmData, alarmTime);
    }
});

// Function referenced by notification button
async function clearCurrentAlarm() {
    try {
        // Clear all alarms (safest approach)
        await clearAllAlarms();
        
        // Remove any visible notifications
        const notifications = document.querySelectorAll('.alarm-notification');
        notifications.forEach(notification => notification.remove());
        
        console.log('Current alarm cleared by user');
    } catch (error) {
        console.error('Failed to clear current alarm:', error);
        alert('Failed to clear alarm. Please try again.');
    }
}

function showAlarmNotification(alarmName, contextData, timestamp) {
    // Example notification display
    const notification = document.createElement('div');
    notification.className = 'alarm-notification critical';
    notification.innerHTML = `
        <div class="alarm-header">‚ö†Ô∏è IRRIGATION ALARM</div>
        <div class="alarm-title">${alarmName}</div>
        <div class="alarm-details">
            <div>Context: ${contextData}</div>
            <div>Time: ${timestamp.toLocaleString()}</div>
        </div>
        <button onclick="clearCurrentAlarm()">Clear Alarm</button>
    `;
    
    document.body.appendChild(notification);
    
    // Auto-remove after 30 seconds if not manually cleared
    setTimeout(() => {
        if (notification.parentNode) {
            notification.remove();
        }
    }, 30000);
}
```

## Alarm Management Utilities

### Alarm History Tracking
```javascript
class AlarmHistory {
    constructor() {
        this.alarms = [];
        this.maxHistory = 50; // Keep last 50 alarms
    }
    
    addAlarm(alarmCode, alarmData, timestamp) {
        const alarm = {
            code: alarmCode,
            data: alarmData,
            timestamp: timestamp,
            dateTime: new Date(timestamp * 1000),
            cleared: false
        };
        
        this.alarms.unshift(alarm); // Add to beginning
        
        // Keep only recent alarms
        if (this.alarms.length > this.maxHistory) {
            this.alarms = this.alarms.slice(0, this.maxHistory);
        }
        
        this.saveToStorage();
    }
    
    clearAlarm(timestamp) {
        const alarm = this.alarms.find(a => a.timestamp === timestamp);
        if (alarm) {
            alarm.cleared = true;
            alarm.clearedAt = new Date();
            this.saveToStorage();
        }
    }
    
    getRecentAlarms(hours = 24) {
        const cutoff = Date.now() - (hours * 60 * 60 * 1000);
        return this.alarms.filter(alarm => 
            alarm.timestamp * 1000 > cutoff
        );
    }
    
    saveToStorage() {
        localStorage.setItem('irrigationAlarmHistory', JSON.stringify(this.alarms));
    }
    
    loadFromStorage() {
        const stored = localStorage.getItem('irrigationAlarmHistory');
        if (stored) {
            this.alarms = JSON.parse(stored);
        }
    }
}

const alarmHistory = new AlarmHistory();
alarmHistory.loadFromStorage();
```

### Alarm Severity Levels
```javascript
function getAlarmSeverity(alarmCode) {
    const severityMap = {
        0: { level: 'info', priority: 0, color: 'green' },      // No alarm
        1: { level: 'warning', priority: 2, color: 'orange' },  // No flow
        2: { level: 'critical', priority: 3, color: 'red' },    // Unexpected flow
        3: { level: 'error', priority: 2, color: 'red' },       // Valve failure
        4: { level: 'warning', priority: 1, color: 'yellow' },  // Sensor error
        5: { level: 'warning', priority: 2, color: 'orange' },  // Low pressure
        6: { level: 'error', priority: 1, color: 'yellow' },    // RTC error
        7: { level: 'warning', priority: 1, color: 'yellow' },  // Temperature
        8: { level: 'info', priority: 1, color: 'blue' },       // Humidity
        9: { level: 'critical', priority: 3, color: 'red' },    // Power supply
        10: { level: 'error', priority: 1, color: 'yellow' },   // Communication
        11: { level: 'warning', priority: 1, color: 'orange' }, // Calibration
        12: { level: 'error', priority: 2, color: 'red' },      // Queue overflow
        13: { level: 'critical', priority: 3, color: 'red' }    // Storage error
    };
    
    return severityMap[alarmCode] || { level: 'unknown', priority: 0, color: 'gray' };
}

function formatAlarmMessage(alarmCode, alarmData) {
    switch(alarmCode) {
        case 1:
            return `No water flow detected after ${alarmData} attempts. Check water supply and valve operation.`;
        case 2:
            return `Unexpected water flow detected (${alarmData} pulses) with all valves closed. Check for leaks.`;
        case 3:
            return `Valve ${alarmData} failed to respond. Check valve connection and power.`;
        case 4:
            return `Flow sensor error detected. Reading: ${alarmData}. Check sensor connection.`;
        case 5:
            return `Low water pressure detected: ${alarmData}. Check water supply.`;
        default:
            return `System alarm ${alarmCode} with context data: ${alarmData}`;
    }
}
```

### Alarm Dashboard Integration
```javascript
// Real-time alarm status display
function updateAlarmDisplay(alarmData) {
    const alarmStatus = document.getElementById('alarm-status');
    const alarmCode = alarmData.getUint8(0);
    const severity = getAlarmSeverity(alarmCode);
    
    if (alarmCode === 0) {
        alarmStatus.className = 'status-normal';
        alarmStatus.textContent = '‚úÖ System Normal';
    } else {
        alarmStatus.className = `status-alarm ${severity.level}`;
        alarmStatus.textContent = `‚ö†Ô∏è ${formatAlarmMessage(alarmCode, alarmData.getUint16(1, true))}`;
    }
}

// Alarm acknowledgment system
async function acknowledgeAlarm() {
    try {
        await clearAllAlarms();
        console.log('Alarm acknowledged and cleared');
        updateSystemStatus();
    } catch (error) {
        console.error('Failed to acknowledge alarm:', error);
    }
}
```

## Related Characteristics

- **[System Status](03-system-status.md)** - System status reflects active alarms
- **[Flow Sensor](02-flow-sensor.md)** - Source of flow-related alarms
- **[Valve Control](01-valve-control.md)** - Valve operations can trigger alarms
- **[Task Queue Management](07-task-queue-management.md)** - Task failures generate alarms
- **[RTC Configuration](09-rtc-configuration.md)** - Provides alarm timestamps
