# Current Task Status Characteristic

**UUID:** `12345678-1234-5678-1234-56789abcdeff`  
**Properties:** Read, Write, Notify  
**Size:** 21 bytes  
**Description:** Real-time task progress monitoring and control for active watering operations

## Overview

The Current Task Status characteristic provides real-time monitoring and control of the currently active watering task. It tracks progress, elapsed time, volume dispensed, and supports task control commands with automatic progress notifications.

**Real-time Progress:** ‚úÖ Time-based and volume-based tracking  
**Task Control:** ‚úÖ Pause, resume, stop commands  
**Auto Notifications:** ‚úÖ Updates every 2 seconds during watering  
**Fragmentation:** ‚ùå NOT REQUIRED - 21 bytes fit in single BLE packet  
**Rate Limiting:** ‚úÖ 500ms minimum delay between notifications to prevent buffer overflow

## Data Structure

```c
struct current_task_data {
    uint8_t channel_id;        // Channel ID (0-7) or 0xFF if no active task
    uint32_t start_time;       // Task start timestamp (Unix UTC, little-endian)
    uint8_t mode;              // Watering mode (0=duration, 1=volume)
    uint32_t target_value;     // Target: seconds (duration) or ml (volume, little-endian)
    uint32_t current_value;    // Current: elapsed seconds or volume dispensed (little-endian)
    uint32_t total_volume;     // Total volume dispensed in ml (little-endian)
    uint8_t status;            // Task status (0=idle, 1=running, 2=completed, 3=paused)
    uint16_t reserved;         // Elapsed time for volume mode (seconds, little-endian)
} __packed;                   // TOTAL SIZE: 21 bytes
```

## Field Descriptions

| Offset | Size | Field | Description |
|--------|------|-------|-------------|
| 0 | 1 | `channel_id` | Active channel (0-7) or 0xFF if none |
| 1-4 | 4 | `start_time` | Task start timestamp (Unix UTC, little-endian) |
| 5 | 1 | `mode` | Watering mode (0=duration, 1=volume) |
| 6-9 | 4 | `target_value` | Target amount: seconds or ml (little-endian) |
| 10-13 | 4 | `current_value` | Current progress: seconds or ml (little-endian) |
| 14-17 | 4 | `total_volume` | Total volume dispensed in ml (little-endian) |
| 18 | 1 | `status` | Task status (0-3) |
| 19-20 | 2 | `reserved` | Elapsed time for volume mode (little-endian) |

### channel_id (byte 0)
- **Range:** 0-7 for active channels, 0xFF for no active task
- **Usage:** Identifies which channel is currently watering

### start_time (bytes 1-4, little-endian)
- **Format:** Unix UTC timestamp (seconds since January 1, 1970)
- **Purpose:** Task start time for accurate duration calculation
- **Source:** Generated by `timezone_get_unix_utc()` using RTC
- **Persistence:** Maintains accurate timing across potential interruptions
- **Time Zone:** UTC for internal consistency (convert to local time for display)

### mode (byte 5)
- `0` - **Duration mode** (target_value in seconds)
- `1` - **Volume mode** (target_value in milliliters)

### target_value (bytes 6-9, little-endian)
- **Duration mode:** Target watering time in seconds
- **Volume mode:** Target volume to dispense in milliliters
- **Range:** 0 to 4,294,967,295

### current_value (bytes 10-13, little-endian)
- **Duration mode:** Elapsed watering time in seconds
- **Volume mode:** Volume dispensed so far in milliliters
- **Usage:** Progress calculation (current_value / target_value)

### total_volume (bytes 14-17, little-endian)
- **Purpose:** Actual volume dispensed regardless of mode
- **Unit:** Milliliters
- **Source:** Flow sensor measurements

### status (byte 18)
- `0` - **Idle** (no active task)
- `1` - **Running** (task in progress)
- `2` - **Paused** (task paused, can be resumed)
- `3` - **Completed** (task finished successfully)

### reserved (bytes 19-20, little-endian)
- **Volume mode:** Elapsed time since task start (using RTC-based calculation)
- **Duration mode:** Elapsed time since task start (using boot-relative timing)
- **Purpose:** Provides timing information for both watering modes
- **Calculation:** 
  - **Volume mode:** `timezone_get_unix_utc() - start_time`
  - **Duration mode:** `k_uptime_get_32() / 1000 - start_time_boot`

## Operations

### READ - Query Task Status
Monitor current watering task progress and status.

```javascript
const data = await taskChar.readValue();
const view = new DataView(data.buffer);

const task = {
    channelId: view.getUint8(0),
    startTime: view.getUint32(1, true),    // little-endian
    mode: view.getUint8(5),
    targetValue: view.getUint32(6, true),  // little-endian
    currentValue: view.getUint32(10, true), // little-endian
    totalVolume: view.getUint32(14, true),  // little-endian
    status: view.getUint8(18),
    elapsedTime: view.getUint16(19, true)   // little-endian
};

// Check if task is active
if (task.channelId === 0xFF) {
    console.log('No active watering task');
} else {
    const statusNames = ['Idle', 'Running', 'Completed', 'Paused'];
    const modeNames = ['Duration', 'Volume'];
    
    console.log(`Channel ${task.channelId}: ${statusNames[task.status]}`);
    console.log(`Mode: ${modeNames[task.mode]}`);
    
    // Calculate progress
    const progress = (task.currentValue / task.targetValue * 100).toFixed(1);
    console.log(`Progress: ${progress}%`);
    
    if (task.mode === 0) {
        // Duration mode
        console.log(`Target: ${task.targetValue} seconds`);
        console.log(`Elapsed: ${task.currentValue} seconds`);
        console.log(`Remaining: ${task.targetValue - task.currentValue} seconds`);
    } else {
        // Volume mode
        console.log(`Target: ${task.targetValue} ml`);
        console.log(`Dispensed: ${task.currentValue} ml`);
        console.log(`Remaining: ${task.targetValue - task.currentValue} ml`);
        console.log(`Elapsed time: ${task.elapsedTime} seconds`);
    }
    
    console.log(`Total volume: ${task.totalVolume} ml`);
    
    // Calculate flow rate if running
    if (task.status === 1 && task.elapsedTime > 0) {
        const flowRate = (task.totalVolume / task.elapsedTime * 60).toFixed(1);
        console.log(`Current flow rate: ${flowRate} ml/min`);
    }
}
```

### WRITE - Task Control Commands
Control active watering tasks with single-byte commands.

```javascript
// Stop current task immediately
async function stopCurrentTask() {
    const stopCommand = new Uint8Array([0x00]);
    await taskChar.writeValue(stopCommand);
    console.log('‚èπÔ∏è Watering task stopped');
}

// Pause current task
async function pauseCurrentTask() {
    const pauseCommand = new Uint8Array([0x01]);
    await taskChar.writeValue(pauseCommand);
    console.log('‚è∏Ô∏è Watering task paused');
}

// Resume paused task
async function resumeCurrentTask() {
    const resumeCommand = new Uint8Array([0x02]);
    await taskChar.writeValue(resumeCommand);
    console.log('‚ñ∂Ô∏è Watering task resumed');
}

// Emergency stop with confirmation
async function emergencyStop() {
    const confirmed = confirm('Emergency stop will immediately halt all watering. Continue?');
    if (confirmed) {
        await stopCurrentTask();
        console.log('üö® Emergency stop executed');
        
        // Optionally notify user
        showNotification('Emergency stop activated', 'error');
    }
}
```

### NOTIFY - Real-time Progress Updates
Receive automatic notifications every 2 seconds during active watering.

```javascript
await taskChar.startNotifications();

taskChar.addEventListener('characteristicvaluechanged', (event) => {
    const data = event.target.value;
    const view = new DataView(data.buffer);
    
    const channelId = view.getUint8(0);
    const mode = view.getUint8(5);
    const targetValue = view.getUint32(6, true);
    const currentValue = view.getUint32(10, true);
    const totalVolume = view.getUint32(14, true);
    const status = view.getUint8(18);
    const elapsedTime = view.getUint16(19, true);
    
    // Handle different status updates
    switch(status) {
        case 0: // Idle
            console.log('üí§ No active watering task');
            updateProgressBar(0, 'idle');
            break;
            
        case 1: // Running
            const progress = (currentValue / targetValue * 100);
            console.log(`üíß Channel ${channelId}: ${progress.toFixed(1)}% complete`);
            
            if (mode === 0) {
                // Duration mode
                const remaining = targetValue - currentValue;
                console.log(`   ${remaining} seconds remaining`);
                updateProgressBar(progress, 'running', `${remaining}s left`);
            } else {
                // Volume mode
                const remaining = targetValue - currentValue;
                console.log(`   ${remaining} ml remaining (${elapsedTime}s elapsed)`);
                updateProgressBar(progress, 'running', `${remaining}ml left`);
            }
            
            // Calculate and display flow rate
            if (elapsedTime > 0) {
                const flowRate = (totalVolume / elapsedTime * 60).toFixed(1);
                console.log(`   Flow rate: ${flowRate} ml/min`);
                updateFlowRateDisplay(flowRate);
            }
            break;
            
        case 2: // Completed
            console.log(`‚úÖ Watering completed on Channel ${channelId}`);
            console.log(`   Total volume: ${totalVolume} ml`);
            console.log(`   Total time: ${elapsedTime} seconds`);
            updateProgressBar(100, 'completed', 'Finished!');
            showTaskCompletionNotification(channelId, totalVolume, elapsedTime);
            break;
            
        case 3: // Paused
            const pausedProgress = (currentValue / targetValue * 100);
            console.log(`‚è∏Ô∏è Channel ${channelId}: Paused at ${pausedProgress.toFixed(1)}%`);
            updateProgressBar(pausedProgress, 'paused', 'Paused');
            break;
    }
    
    // Update task status display
    updateTaskStatusDisplay(channelId, status, currentValue, targetValue, mode);
});

function updateProgressBar(percentage, state, label = '') {
    const progressBar = document.getElementById('task-progress');
    const progressLabel = document.getElementById('task-label');
    
    if (progressBar) {
        progressBar.style.width = `${percentage}%`;
        progressBar.className = `progress-bar ${state}`;
    }
    
    if (progressLabel) {
        progressLabel.textContent = label || `${percentage.toFixed(1)}%`;
    }
}

function updateFlowRateDisplay(flowRate) {
    const flowElement = document.getElementById('flow-rate');
    if (flowElement) {
        flowElement.textContent = `${flowRate} ml/min`;
    }
}

function showTaskCompletionNotification(channelId, volume, duration) {
    const notification = document.createElement('div');
    notification.className = 'task-notification success';
    notification.innerHTML = `
        <div class="notification-header">‚úÖ Watering Complete</div>
        <div class="notification-body">
            <div>Channel: ${channelId}</div>
            <div>Volume: ${volume} ml</div>
            <div>Duration: ${Math.floor(duration / 60)}m ${duration % 60}s</div>
        </div>
    `;
    
    document.body.appendChild(notification);
    
    // Auto-remove after 10 seconds
    setTimeout(() => {
        notification.remove();
    }, 10000);
}
```

## Task Control Utilities

### Progress Monitoring
```javascript
class TaskMonitor {
    constructor(characteristic) {
        this.taskChar = characteristic;
        this.isMonitoring = false;
        this.startTime = null;
        this.lastUpdate = null;
    }
    
    async startMonitoring() {
        if (this.isMonitoring) return;
        
        this.isMonitoring = true;
        await this.taskChar.startNotifications();
        
        this.taskChar.addEventListener('characteristicvaluechanged', (event) => {
            this.handleTaskUpdate(event.target.value);
        });
        
        console.log('üìä Task monitoring started');
    }
    
    async stopMonitoring() {
        this.isMonitoring = false;
        await this.taskChar.stopNotifications();
        console.log('üìä Task monitoring stopped');
    }
    
    handleTaskUpdate(data) {
        const view = new DataView(data.buffer);
        const status = view.getUint8(18);
        const channelId = view.getUint8(0);
        
        const update = {
            timestamp: new Date(),
            channelId: channelId,
            status: status,
            currentValue: view.getUint32(10, true),
            targetValue: view.getUint32(6, true),
            totalVolume: view.getUint32(14, true),
            mode: view.getUint8(5)
        };
        
        this.lastUpdate = update;
        
        // Log significant events
        if (status === 1 && !this.startTime) {
            this.startTime = update.timestamp;
            console.log(`üöÄ Task started on Channel ${channelId}`);
        } else if (status === 2) {
            const duration = this.startTime ? 
                (update.timestamp - this.startTime) / 1000 : 0;
            console.log(`üèÅ Task completed in ${duration.toFixed(1)} seconds`);
            this.startTime = null;
        }
        
        this.onTaskUpdate(update);
    }
    
    onTaskUpdate(update) {
        // Override in subclass for custom handling
        console.log('Task update:', update);
    }
    
    getProgress() {
        if (!this.lastUpdate) return null;
        
        return {
            percentage: (this.lastUpdate.currentValue / this.lastUpdate.targetValue) * 100,
            remaining: this.lastUpdate.targetValue - this.lastUpdate.currentValue,
            status: this.lastUpdate.status
        };
    }
}

// Usage
const monitor = new TaskMonitor(taskChar);
await monitor.startMonitoring();

// Custom monitoring with alerts
class AlertingTaskMonitor extends TaskMonitor {
    onTaskUpdate(update) {
        super.onTaskUpdate(update);
        
        // Alert on completion
        if (update.status === 2) {
            this.showCompletionAlert(update);
        }
        
        // Alert on errors (status changes to idle unexpectedly)
        if (update.status === 0 && this.startTime) {
            this.showErrorAlert(update);
        }
    }
    
    showCompletionAlert(update) {
        if ('Notification' in window && Notification.permission === 'granted') {
            new Notification('Watering Complete', {
                body: `Channel ${update.channelId}: ${update.totalVolume}ml dispensed`,
                icon: '/irrigation-icon.png'
            });
        }
    }
    
    showErrorAlert(update) {
        console.warn('‚ö†Ô∏è Task may have stopped unexpectedly');
        // Handle error notification
    }
}
```

### Task Control Panel
```javascript
function createTaskControlPanel() {
    const panel = document.createElement('div');
    panel.className = 'task-control-panel';
    panel.innerHTML = `
        <div class="panel-header">Watering Control</div>
        <div class="task-status" id="task-status">No active task</div>
        <div class="progress-container">
            <div class="progress-bar" id="task-progress"></div>
            <div class="progress-label" id="task-label">0%</div>
        </div>
        <div class="flow-rate" id="flow-rate">0 ml/min</div>
        <div class="control-buttons">
            <button id="pause-btn" onclick="pauseCurrentTask()" disabled>Pause</button>
            <button id="resume-btn" onclick="resumeCurrentTask()" disabled>Resume</button>
            <button id="stop-btn" onclick="emergencyStop()" disabled>Stop</button>
        </div>
    `;
    
    return panel;
}

function updateTaskStatusDisplay(channelId, status, current, target, mode) {
    const statusElement = document.getElementById('task-status');
    const pauseBtn = document.getElementById('pause-btn');
    const resumeBtn = document.getElementById('resume-btn');
    const stopBtn = document.getElementById('stop-btn');
    
    const statusNames = ['Idle', 'Running', 'Completed', 'Paused'];
    const modeNames = ['Duration', 'Volume'];
    
    if (channelId === 0xFF || status === 0) {
        statusElement.textContent = 'No active task';
        pauseBtn.disabled = true;
        resumeBtn.disabled = true;
        stopBtn.disabled = true;
    } else {
        statusElement.textContent = `Channel ${channelId}: ${statusNames[status]} (${modeNames[mode]} mode)`;
        
        pauseBtn.disabled = status !== 1; // Enable only when running
        resumeBtn.disabled = status !== 3; // Enable only when paused
        stopBtn.disabled = status === 0 || status === 2; // Disable when idle or completed
    }
}
```

## Related Characteristics

- **[Task Queue Management](07-task-queue-management.md)** - Queue control and task scheduling
- **[Valve Control](01-valve-control.md)** - Manual valve operations
- **[Flow Sensor](02-flow-sensor.md)** - Volume measurement for progress tracking
- **[System Status](03-system-status.md)** - Overall system status during tasks
- **[Statistics](08-statistics.md)** - Task completion history and metrics
